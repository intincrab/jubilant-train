# WebAssembly Integration in Tiny Compiler

This document provides a detailed technical explanation of how the Tiny Compiler uses WebAssembly to run C code in the browser.

## What is WebAssembly?

WebAssembly (WASM) is a binary instruction format designed as a portable compilation target for programming languages like C/C++. It enables high-performance applications on web browsers with near-native execution speed.

Key characteristics:
- Binary format (smaller payload than JavaScript)
- Fast decoding and execution
- Memory-safe sandboxed execution model
- Works alongside JavaScript

## C to WebAssembly Compilation Process

### 1. Compilation Pipeline

Our C code goes through several stages to become WebAssembly:

```
C Code → LLVM IR → WebAssembly Binary → Browser Execution
```

This is handled by Emscripten, a toolchain based on LLVM, which:
1. Compiles C/C++ to LLVM Intermediate Representation
2. Optimizes the LLVM IR
3. Converts the IR to WebAssembly binary format
4. Generates JavaScript glue code to load and interface with the WebAssembly module

### 2. Makefile Configuration

The Makefile for our WebAssembly build uses specific flags:

```makefile
WASM_CFLAGS = -s WASM=1 -s EXPORTED_FUNCTIONS='["_compile", "_free_result", "_malloc", "_free"]' -s EXPORTED_RUNTIME_METHODS='["ccall", "cwrap", "UTF8ToString"]' -s ALLOW_MEMORY_GROWTH=1
```

Let's examine each flag:

- `-s WASM=1`: Generate WebAssembly output (instead of asm.js)
- `-s EXPORTED_FUNCTIONS`: Functions that JavaScript can call directly
  - `_compile`: Our main function that compiles source code
  - `_free_result`: Frees memory allocated for results
  - `_malloc` and `_free`: Memory management functions
- `-s EXPORTED_RUNTIME_METHODS`: Helper JavaScript methods
  - `ccall`: Call C functions directly
  - `cwrap`: Create reusable JavaScript function wrappers around C functions
  - `UTF8ToString`: Convert C strings to JavaScript strings
- `-s ALLOW_MEMORY_GROWTH=1`: Allow dynamic memory allocation

### 3. C Code Exports

In `main.c`, we use `EMSCRIPTEN_KEEPALIVE` or list functions in `EXPORTED_FUNCTIONS` to make them accessible from JavaScript:

```c
#ifdef __EMSCRIPTEN__
#include <emscripten.h>
#endif

// Function exposed to JavaScript
#ifdef __EMSCRIPTEN__
EMSCRIPTEN_KEEPALIVE
char* compile(const char* source) {
    return compile_string(source);
}

EMSCRIPTEN_KEEPALIVE
void free_result(char* result) {
    free_code(result);
}
#endif
```

## Memory Management Between JavaScript and WebAssembly

### 1. Linear Memory Model

WebAssembly uses a linear memory model - a contiguous, byte-addressable array that both JavaScript and WebAssembly can access.

When our C compiler:
- Allocates memory with `malloc`
- Returns a string with `compile_string`

It's operating on this shared memory space.

### 2. String Handling

Strings are handled differently between JavaScript and C:
- C: Null-terminated byte arrays
- JavaScript: UTF-16 encoded string objects

When passing strings:
1. JavaScript to C: Emscripten automatically converts and copies
2. C to JavaScript: We get a memory pointer (number) which needs conversion

Example flow:
```
JS Input → C String → C Processing → C String Result → Memory Pointer → JS String
```

### 3. Memory Leaks Prevention

We must free memory after use to prevent memory leaks:

```javascript
// In JavaScript
const resultPtr = compileFunction(source);
const result = Module.UTF8ToString(resultPtr);
freeResultFunction(resultPtr); // Must free the memory!
```

## Browser Integration

### 1. Loading the WebAssembly Module

The JavaScript glue code generated by Emscripten handles:
- Fetching the .wasm binary
- Compiling the WebAssembly module
- Instantiating the module
- Setting up the shared memory
- Creating JavaScript bindings for exported functions

### 2. Module Initialization

In our HTML, we set up the Module object:

```javascript
var Module = {
    onRuntimeInitialized: function() {
        compileFunction = Module.cwrap('compile', 'number', ['string']);
        freeResultFunction = Module.cwrap('free_result', null, ['number']);
        
        // Enable the compile button after loading
        document.getElementById('compile').removeAttribute('disabled');
    }
};
```

The `onRuntimeInitialized` callback fires when the WebAssembly module is fully loaded and ready to use.

### 3. Function Wrappers

We use `cwrap` to create JavaScript function wrappers around the C functions:

```javascript
compileFunction = Module.cwrap(
    'compile',    // C function name
    'number',     // Return type (memory address)
    ['string']    // Parameter types
);

freeResultFunction = Module.cwrap(
    'free_result', // C function name
    null,          // Return type (void)
    ['number']     // Parameter types (memory address)
);
```

### 4. Compilation Process in the Browser

When a user clicks "Compile":

```javascript
function compileCode() {
    const source = document.getElementById('source').value;
    
    try {
        // Call the WebAssembly function with source code
        const resultPtr = compileFunction(source);
        
        // Convert memory pointer to JavaScript string
        const result = Module.UTF8ToString(resultPtr);
        
        // Free the allocated memory
        freeResultFunction(resultPtr);
        
        // Display result
        document.getElementById('output').value = result;
    } catch (error) {
        console.error('Compilation error:', error);
    }
}
```

## Error Handling and Fallbacks

Our implementation includes error handling and fallbacks:

1. If WebAssembly fails to load, we fall back to a JavaScript implementation
2. If the browser doesn't support WebAssembly, we display a warning
3. For C runtime errors, we catch and display them

## Performance Considerations

- WebAssembly typically runs at 80-90% of native speed
- String conversions and memory copies introduce some overhead
- Larger inputs may require increasing the memory allocation
- First load has compilation overhead, but subsequent operations are fast

## Browser Compatibility

WebAssembly is supported in all major browsers:
- Chrome 57+
- Firefox 52+
- Safari 11+
- Edge 16+

For older browsers, a JavaScript fallback is provided.

## Debugging WebAssembly

Debugging WebAssembly is challenging, but several options exist:

1. Using Emscripten's `-g` flag for debug info
2. Chrome/Edge DevTools can step through WebAssembly
3. Firefox also has WebAssembly debugging capabilities
4. Add logging to C code with `printf` which maps to `console.log`

## Security Considerations

- WebAssembly runs in the same security sandbox as JavaScript
- Cannot access the file system (except through browser APIs)
- Memory is protected from out-of-bounds access
- No direct system call access 