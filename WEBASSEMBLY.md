# WebAssembly Integration in Tiny Compiler

This document provides a detailed technical explanation of how the Tiny Compiler uses WebAssembly to run C code in the browser.

## What is WebAssembly?

WebAssembly (WASM) is a binary instruction format designed as a portable compilation target for programming languages like C/C++. It enables high-performance applications on web browsers with near-native execution speed.

Key characteristics:
- Binary format (smaller payload than JavaScript)
- Fast decoding and execution
- Memory-safe sandboxed execution model
- Works alongside JavaScript

## C to WebAssembly Compilation Process

### 1. Compilation Pipeline

Our C code goes through several stages to become WebAssembly:

```
C Code → LLVM IR → WebAssembly Binary → Browser Execution
```

This is handled by Emscripten, a toolchain based on LLVM, which:
1. Compiles C/C++ to LLVM Intermediate Representation
2. Optimizes the LLVM IR
3. Converts the IR to WebAssembly binary format
4. Generates JavaScript glue code to load and interface with the WebAssembly module

### 2. Makefile Configuration

The Makefile for our WebAssembly build uses specific flags:

```makefile
WASM_CFLAGS = -s WASM=1 -s EXPORTED_FUNCTIONS='["_compile", "_free_result", "_malloc", "_free"]' -s EXPORTED_RUNTIME_METHODS='["ccall", "cwrap", "UTF8ToString"]' -s ALLOW_MEMORY_GROWTH=1
```

Let's examine each flag:

- `-s WASM=1`: Generate WebAssembly output (instead of asm.js)
- `-s EXPORTED_FUNCTIONS`: Functions that JavaScript can call directly
  - `_compile`: Our main function that compiles source code
  - `_free_result`: Frees memory allocated for results
  - `_malloc` and `_free`: Memory management functions
- `-s EXPORTED_RUNTIME_METHODS`: Helper JavaScript methods
  - `ccall`: Call C functions directly
  - `cwrap`: Create reusable JavaScript function wrappers around C functions
  - `UTF8ToString`: Convert C strings to JavaScript strings
- `-s ALLOW_MEMORY_GROWTH=1`: Allow dynamic memory allocation

### 3. C Code Exports

In `main.c`, we use `EMSCRIPTEN_KEEPALIVE` or list functions in `EXPORTED_FUNCTIONS` to make them accessible from JavaScript:

```c
#ifdef __EMSCRIPTEN__
#include <emscripten.h>
#endif

// Function exposed to JavaScript
#ifdef __EMSCRIPTEN__
EMSCRIPTEN_KEEPALIVE
char* compile(const char* source) {
    return compile_string(source);
}

EMSCRIPTEN_KEEPALIVE
void free_result(char* result) {
    free_code(result);
}
#endif
```

## Memory Management Between JavaScript and WebAssembly

### 1. Linear Memory Model

WebAssembly uses a linear memory model - a contiguous, byte-addressable array that both JavaScript and WebAssembly can access.

When our C compiler:
- Allocates memory with `malloc`
- Returns a string with `compile_string`

It's operating on this shared memory space.

### 2. String Handling

Strings are handled differently between JavaScript and C:
- C: Null-terminated byte arrays
- JavaScript: UTF-16 encoded string objects

When passing strings:
1. JavaScript to C: Emscripten automatically converts and copies
2. C to JavaScript: We get a memory pointer (number) which needs conversion

Example flow:
```
JS Input → C String → C Processing → C String Result → Memory Pointer → JS String
```

### 3. Memory Leaks Prevention

We must free memory after use to prevent memory leaks:

```javascript
// In JavaScript
const resultPtr = compileFunction(source);
const result = Module.UTF8ToString(resultPtr);
freeResultFunction(resultPtr); // Must free the memory!
```

## Browser Integration

### 1. Loading the WebAssembly Module

The JavaScript glue code generated by Emscripten handles:
- Fetching the .wasm binary
- Compiling the WebAssembly module
- Instantiating the module
- Setting up the shared memory
- Creating JavaScript bindings for exported functions

### 2. Module Initialization

In our HTML, we set up the Module object:

```javascript
var Module = {
    onRuntimeInitialized: function() {
        compileFunction = Module.cwrap('compile', 'number', ['string']);
        freeResultFunction = Module.cwrap('free_result', null, ['number']);
        
        // Enable the compile button after loading
        document.getElementById('compile').removeAttribute('disabled');
    }
};
```

The `onRuntimeInitialized` callback fires when the WebAssembly module is fully loaded and ready to use.

### 3. Function Wrappers

We use `cwrap` to create JavaScript function wrappers around the C functions:

```javascript
compileFunction = Module.cwrap(
    'compile',    // C function name
    'number',     // Return type (memory address)
    ['string']    // Parameter types
);

freeResultFunction = Module.cwrap(
    'free_result', // C function name
    null,          // Return type (void)
    ['number']     // Parameter types (memory address)
);
```

### 4. Compilation Process in the Browser

When a user clicks "Compile":

```javascript
function compileCode() {
    const source = document.getElementById('source').value;
    
    try {
        // Call the WebAssembly function with source code
        const resultPtr = compileFunction(source);
        
        // Convert memory pointer to JavaScript string
        const result = Module.UTF8ToString(resultPtr);
        
        // Free the allocated memory
        freeResultFunction(resultPtr);
        
        // Display result
        document.getElementById('output').value = result;
    } catch (error) {
        console.error('Compilation error:', error);
    }
}
```

## Error Handling and Fallbacks

Our implementation includes error handling and fallbacks:

1. If WebAssembly fails to load, we fall back to a JavaScript implementation
2. If the browser doesn't support WebAssembly, we display a warning
3. For C runtime errors, we catch and display them

## Performance Considerations

- WebAssembly typically runs at 80-90% of native speed
- String conversions and memory copies introduce some overhead
- Larger inputs may require increasing the memory allocation
- First load has compilation overhead, but subsequent operations are fast

## Browser Compatibility

WebAssembly is supported in all major browsers:
- Chrome 57+
- Firefox 52+
- Safari 11+
- Edge 16+

For older browsers, a JavaScript fallback is provided.

## Debugging WebAssembly

Debugging WebAssembly is challenging, but several options exist:

1. Using Emscripten's `-g` flag for debug info
2. Chrome/Edge DevTools can step through WebAssembly
3. Firefox also has WebAssembly debugging capabilities
4. Add logging to C code with `printf` which maps to `console.log`

## Security Considerations

- WebAssembly runs in the same security sandbox as JavaScript
- Cannot access the file system (except through browser APIs)
- Memory is protected from out-of-bounds access
- No direct system call access 

# WebAssembly Integration - AST Visualization Pipeline

This document explains how the AST visualization works from C code to frontend display, demonstrating the complete pipeline of compiler visualization.

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            BROWSER FRONTEND                                  │
│                                                                             │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────────────────┐  │
│  │   Source Code   │  │  AST Visualizer │  │    Token Visualizer         │  │
│  │   Text Editor   │  │  (Interactive   │  │    (Color-coded tokens)     │  │
│  │                 │  │   Tree Display) │  │                             │  │
│  └─────────────────┘  └─────────────────┘  └─────────────────────────────┘  │
│           │                     ▲                           ▲               │
│           │                     │                           │               │
│           ▼                     │                           │               │
│  ┌─────────────────────────────────────────────────────────────────────────┐  │
│  │                    JavaScript Interface Layer                          │  │
│  │  • Module.cwrap() function bindings                                    │  │
│  │  • Memory management (UTF8ToString, malloc/free)                       │  │
│  │  • JSON parsing and DOM manipulation                                   │  │
│  └─────────────────────────────────────────────────────────────────────────┘  │
│           │                     ▲                           ▲               │
│           │                     │                           │               │
└───────────┼─────────────────────┼───────────────────────────┼───────────────┘
            │                     │                           │
            ▼                     │                           │
┌─────────────────────────────────────────────────────────────────────────────┐
│                         WEBASSEMBLY MODULE                                  │
│                                                                             │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────────────────┐  │
│  │   compile()     │  │   parse_ast()   │  │      tokenize()             │  │
│  │   EXPORTED      │  │   EXPORTED      │  │      EXPORTED               │  │
│  │                 │  │                 │  │                             │  │
│  └─────────────────┘  └─────────────────┘  └─────────────────────────────┘  │
│           │                     │                           │               │
│           ▼                     ▼                           ▼               │
│  ┌─────────────────────────────────────────────────────────────────────────┐  │
│  │                         C COMPILER CORE                                │  │
│  │                                                                         │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐ │  │
│  │  │   Lexer     │  │   Parser    │  │  Code Gen   │  │  AST Serializer │ │  │
│  │  │   (lexer.c) │  │ (parser.c)  │  │ (codegen.c) │  │   (parser.c)    │ │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────────┘ │  │
│  └─────────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

## AST Visualization Pipeline

### 1. C Code: AST Structure Definition

The AST is defined in `src/parser.h` with a union-based structure:

```c
typedef enum {
    AST_PROGRAM,
    AST_VARIABLE,
    AST_NUMBER,
    AST_BINARY_OP,
    AST_ASSIGN,
    AST_IF,
    AST_PRINT
} ASTNodeType;

typedef struct ASTNode {
    ASTNodeType type;
    union {
        struct {
            struct ASTNode** statements;
            size_t statement_count;
        } program;
        
        struct {
            char* name;
        } variable;
        
        struct {
            int value;
        } number;
        
        struct {
            char op;
            struct ASTNode* left;
            struct ASTNode* right;
        } binary_op;
        
        struct {
            char* name;
            struct ASTNode* value;
        } assign;
        
        struct {
            struct ASTNode* condition;
            struct ASTNode* if_body;
            struct ASTNode* else_body;
        } if_statement;
        
        struct {
            struct ASTNode* expression;
        } print;
    } data;
} ASTNode;
```

### 2. C Code: AST to JSON Serialization

The `ast_to_json()` function in `src/parser.c` recursively converts the AST to JSON:

```c
char* ast_to_json_recursive(ASTNode* node, int depth) {
    if (!node) return strdup("null");
    
    // Create formatted JSON with proper indentation
    char* json = malloc(buffer_size);
    sprintf(json, "{\n%s  \"type\": \"%s\",\n%s  \"id\": %p", 
            indent, ast_node_type_to_string(node->type), indent, (void*)node);
    
    // Add node-specific data based on type
    switch (node->type) {
        case AST_PROGRAM:
            // Serialize statements array
            for (size_t i = 0; i < node->data.program.statement_count; i++) {
                char* child_json = ast_to_json_recursive(node->data.program.statements[i], depth + 2);
                strcat(json, child_json);
                free(child_json);
            }
            break;
        case AST_BINARY_OP:
            // Serialize left and right operands
            char* left_json = ast_to_json_recursive(node->data.binary_op.left, depth + 1);
            char* right_json = ast_to_json_recursive(node->data.binary_op.right, depth + 1);
            // ... append to json
            break;
        // ... other node types
    }
    
    return json;
}
```

### 3. WebAssembly Export

The AST parsing function is exported in `src/main.c`:

```c
#ifdef __EMSCRIPTEN__
EMSCRIPTEN_KEEPALIVE
char* parse_ast(const char* source) {
    return parse_to_ast(source);
}

EMSCRIPTEN_KEEPALIVE
void free_ast_json(char* ast_json) {
    free(ast_json);
}
#endif
```

### 4. Compilation to WebAssembly

The C code is compiled to WebAssembly with Emscripten:

```bash
emcc src/*.c -o public/tiny-compiler.js \
  -s WASM=1 \
  -s EXPORTED_FUNCTIONS='["_compile", "_tokenize", "_parse_ast", "_free_result", "_free_tokens", "_free_ast_json"]' \
  -s EXPORTED_RUNTIME_METHODS='["cwrap", "UTF8ToString"]' \
  -s ALLOW_MEMORY_GROWTH=1
```

This generates:
- `tiny-compiler.wasm`: Binary WebAssembly module
- `tiny-compiler.js`: JavaScript glue code

### 5. JavaScript Interface Layer

The frontend creates wrapper functions using `cwrap`:

```javascript
// WebAssembly module initialization
Module = {
    onRuntimeInitialized: function() {
        parseAstFunction = Module.cwrap('parse_ast', 'number', ['string']);
        freeAstJsonFunction = Module.cwrap('free_ast_json', null, ['number']);
        
        // Enable UI buttons
        parseAstBtn.removeAttribute('disabled');
    }
};
```

### 6. Frontend AST Parsing

When the user clicks "Parse AST" or auto-parse is enabled:

```javascript
function parseAst() {
    const source = sourceEl.value.trim();
    
    try {
        // Call WebAssembly function
        const astPtr = parseAstFunction(source);
        
        // Convert C string to JavaScript string
        const astJson = Module.UTF8ToString(astPtr);
        
        // Free C memory
        freeAstJsonFunction(astPtr);
        
        // Parse JSON and display
        const ast = JSON.parse(astJson);
        displayAst(ast);
        updateAstStats(ast);
        
    } catch (error) {
        showError('AST parsing error: ' + error.toString());
    }
}
```

### 7. Interactive AST Visualization

The `displayAst()` function creates an interactive tree visualization:

```javascript
function displayAst(ast) {
    astContainer.innerHTML = '';
    const treeEl = document.createElement('div');
    treeEl.className = 'ast-tree';
    
    const rootNode = createAstNodeElement(ast);
    treeEl.appendChild(rootNode);
    astContainer.appendChild(treeEl);
}

function createAstNodeElement(node) {
    const nodeEl = document.createElement('div');
    nodeEl.className = 'ast-node';
    
    const contentEl = document.createElement('div');
    contentEl.className = `ast-node-content ast-${node.type}`;
    
    // Add node type and details
    const typeEl = document.createElement('div');
    typeEl.className = 'ast-node-type';
    typeEl.textContent = node.type;
    
    const detailsEl = document.createElement('div');
    detailsEl.className = 'ast-node-details';
    
    // Add node-specific details
    switch (node.type) {
        case 'PROGRAM':
            detailsEl.textContent = `${node.statement_count || 0} statements`;
            break;
        case 'VARIABLE':
            detailsEl.textContent = node.name || 'unnamed';
            break;
        case 'NUMBER':
            detailsEl.textContent = node.value?.toString() || '0';
            break;
        case 'BINARY_OP':
            detailsEl.textContent = node.operator || '?';
            break;
        // ... other node types
    }
    
    // Recursively add children
    const children = getNodeChildren(node);
    if (children.length > 0) {
        const childrenEl = document.createElement('div');
        childrenEl.className = 'ast-children';
        
        children.forEach(child => {
            const childEl = createAstNodeElement(child);
            childrenEl.appendChild(childEl);
        });
        
        nodeEl.appendChild(childrenEl);
    }
    
    return nodeEl;
}
```

## Visual Design Features

### Color-Coded Node Types

Each AST node type has a distinct color scheme:

```css
.ast-PROGRAM { border-color: #3b82f6; background: #eff6ff; }
.ast-ASSIGN { border-color: #ec4899; background: #fdf2f8; }
.ast-VARIABLE { border-color: #10b981; background: #ecfdf5; }
.ast-NUMBER { border-color: #a855f7; background: #faf5ff; }
.ast-BINARY_OP { border-color: #f59e0b; background: #fffbeb; }
.ast-IF { border-color: #ef4444; background: #fef2f2; }
.ast-PRINT { border-color: #84cc16; background: #f7fee7; }
```

### Interactive Features

- **Hover Effects**: Nodes lift up with enhanced shadows
- **Node Details**: Each node shows type-specific information
- **Responsive Layout**: Adapts to different screen sizes
- **Tab Switching**: Toggle between AST and token views
- **Auto-Parse**: Real-time updates as you type
- **Statistics**: Shows node count and tree depth

### Memory Management

The system properly manages memory across the C/WebAssembly boundary:

1. **C Side**: Uses `malloc()` to allocate JSON strings
2. **JavaScript Side**: Uses `UTF8ToString()` to convert C strings
3. **Cleanup**: Calls `free_ast_json()` to prevent memory leaks

## Example AST Visualization

For the input code:
```
x = 10;
if (x > 5) {
    print(x);
}
```

The AST visualization shows:
- **PROGRAM** node (root) with 2 statements
- **ASSIGN** node for `x = 10`
  - **VARIABLE** node for `x`
  - **NUMBER** node for `10`
- **IF** node for the conditional
  - **BINARY_OP** node for `x > 5`
    - **VARIABLE** node for `x`
    - **NUMBER** node for `5`
  - **PROGRAM** node for if body
    - **PRINT** node
      - **VARIABLE** node for `x`

## Performance Benefits

1. **WebAssembly Speed**: AST parsing runs at near-native C speed
2. **Efficient Serialization**: Direct JSON generation in C
3. **Minimal Memory Overhead**: Immediate cleanup after use
4. **Real-time Updates**: Fast enough for auto-parse mode

## Browser Compatibility

The AST visualization works in all modern browsers that support:
- WebAssembly (all major browsers since 2017)
- ES6 JavaScript features
- CSS Grid and Flexbox
- Modern DOM APIs

This complete pipeline demonstrates how complex compiler data structures can be efficiently visualized in web browsers using WebAssembly as a bridge between C and JavaScript. 
